#!/usr/bin/env python3
import os
from datetime import datetime

import paho.mqtt.client as mqtt
import mysql.connector

# -------- CONFIG --------
IMAGES_DIR = "/home/etann/Pictures"

DB_CONFIG = {
    "host": "localhost",
    "user": "birduser",        # üî¥ A ADAPTER : utilisateur MariaDB
    "password": "birdcam123",    # üî¥ A ADAPTER : mot de passe MariaDB
    "database": "birdcam",
}

MAX_IMAGES = 50

os.makedirs(IMAGES_DIR, exist_ok=True)

# -------- Variables pour la reconstruction --------
current_buffer = bytearray()
expected_size = 0
receiving = False


# -------- Fonctions DB --------
def db_connect():
    return mysql.connector.connect(**DB_CONFIG)


def save_to_db(filename, path):
    conn = db_connect()
    cur = conn.cursor()
    cur.execute(
        "INSERT INTO photos (ts, topic, filename, path) VALUES (NOW(), %s, %s, %s)",
        ("test/data", filename, path),
    )
    conn.commit()
    cur.close()
    conn.close()


def cleanup_old_images():
    """Garde seulement les MAX_IMAGES derni√®res entr√©es (et supprime les fichiers associ√©s)."""
    conn = db_connect()
    cur = conn.cursor()

    # R√©cup√®re les id tri√©s du plus r√©cent au plus ancien
    cur.execute("SELECT id FROM photos ORDER BY id DESC")
    rows = cur.fetchall()
    ids = [r[0] for r in rows]

    if len(ids) > MAX_IMAGES:
        ids_to_delete = ids[MAX_IMAGES:]

        # R√©cup√®re les chemins des images √† supprimer
        format_ids = ",".join(str(i) for i in ids_to_delete)
        cur.execute(f"SELECT path FROM photos WHERE id IN ({format_ids})")
        for (p,) in cur.fetchall():
            if p and os.path.exists(p):
                try:
                    os.remove(p)
                    print(f"[CLEAN] Fichier supprim√© : {p}")
                except Exception as e:
                    print(f"[CLEAN] Erreur suppression {p} : {e}")

        # Supprime les lignes dans la base
        cur.execute(f"DELETE FROM photos WHERE id IN ({format_ids})")
        conn.commit()
        print(f"[CLEAN] Supprim√© {len(ids_to_delete)} images en base.")

    cur.close()
    conn.close()


# -------- Callbacks MQTT --------
def on_connect(client, userdata, flags, rc):
    print(f"[MQTT] Connect√©, code : {rc}")
    client.subscribe("test/start")
    client.subscribe("test/data")
    client.subscribe("test/end")
    print("[MQTT] Abonn√© √† test/start, test/data, test/end")


def on_message(client, userdata, msg):
    global current_buffer, expected_size, receiving

    topic = msg.topic
    payload = msg.payload

    # --- d√©but d'image ---
    if topic == "test/start":
        try:
            expected_size = int(payload.decode())
        except ValueError:
            expected_size = 0
        current_buffer = bytearray()
        receiving = True
        print(f"[START] Nouvelle image, taille annonc√©e : {expected_size} octets")

    # --- chunks ---
    elif topic == "test/data" and receiving:
        current_buffer.extend(payload)
        print(f"[DATA] Chunk re√ßu ({len(payload)} octets) ‚Üí total {len(current_buffer)}")

    # --- fin d'image ---
    elif topic == "test/end" and receiving:
        receiving = False
        print(f"[END] Image termin√©e ({len(current_buffer)}/{expected_size} octets)")

        if expected_size != 0 and len(current_buffer) != expected_size:
            print("[WARN] Taille re√ßue diff√©rente de la taille annonc√©e, mais on sauvegarde quand m√™me.")

        # G√©n√®re nom de fichier
        ts = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
        filename = f"{ts}.jpg"
        filepath = os.path.join(IMAGES_DIR, filename)

        # Sauvegarde fichier
        try:
            with open(filepath, "wb") as f:
                f.write(current_buffer)
            print(f"[SAVE] Image sauvegard√©e : {filepath}")
        except Exception as e:
            print(f"[ERROR] Impossible de sauvegarder l'image : {e}")
            current_buffer = bytearray()
            return

        # Sauvegarde en base
        try:
            save_to_db(filename, filepath)
            print("[DB] Image enregistr√©e dans la base.")
        except Exception as e:
            print(f"[DB] Erreur lors de l'enregistrement : {e}")

        # Nettoyage des anciennes images
        try:
            cleanup_old_images()
        except Exception as e:
            print(f"[CLEAN] Erreur nettoyage : {e}")

        # Reset buffer
        current_buffer = bytearray()


# -------- MAIN --------
client = mqtt.Client()
client.on_connect = on_connect
client.on_message = on_message

client.connect("localhost", 1883)

print("En attente d'images MQTT...")
client.loop_forever()

